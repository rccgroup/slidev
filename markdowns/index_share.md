---
# theme: apple-basic
layout: center
---

# 快速查询的秘籍 - 索引
<br>

## - Lyon.Lei

<style>
h2 {
  text-align: right
}
</style>

---
layout: center
---

# 主要分享内容
<br>

<span>1. 没有索引的查找</span>
<br>

<span>2. MySQL 中的索引</span>
<br>

<span>3. 索引的代价</span>
<br>

<span>4. 索引适用的查询以及注意事项</span>

<!--
1. 这部分主要介绍一个普通查询在没有建立索引的查询效率
2. 主要介绍 MySQL 中的索引方案，为什么提升查询效率
3. 这部分主要介绍索引既然提升了查询效率，那么它真的全是好处吗，会不会带来一些额外的代价
4. 这部分主要介绍哪些列建议建立索引，以及哪些查询会用到索引，还有就是建立索引的注意事项
-->

---
layout: center
---
# 没有索引的查找

---

<img src="https://pic-bed-file.oss-cn-shanghai.aliyuncs.com/1624193591646.png" style="width: 80%;" />

<!--
在介绍索引之前需要介绍一下“页”的概念，先举一个例子吧，在公司中我们开发存储于最小的单位是什么呢，可能是项目组，或者职能组。

那数据库中的记录也是有最基本的存储单位，那这个基本的存储单位就是“页”。

那页什么时候存满呢，其实一个页只有 16KB 存满了，那么数据库会在建立新的页来存储新的数据。
-->

---

## 在一个页中查找
<br>

```sql
SELECT id, name FROM USERS WHERE id = 1
```
<br>

```sql
SELECT id, name FROM USERS WHERE name = 'lyon.lei'
```
<br>

- 以主键为搜索条件
  - 我们可以通过页目录进行二分查找，快速定位到对应的记录

- 以其他列作为搜索条件
  - 如果搜索条件不是主键，那么可能就有些费力了，不能通过页目录快速定位对应记录，只能通过从最小的记录开始遍历页中所有的记录，然后对比每条记录是否符合条件。

<!--
假设我们数据量很少，不需要考虑多个页情况下，记录都放在一个页中。
-->

---

## 在多个页中查找

<div style="margin-top:90px">

- 以主键为搜索条件
  - 从第一页沿着双向链表一直往下找，通过每页的页目录判断查找的条件是否符合，如果符合则通过二分查找，定位对应的记录

<br>
<br>
<br>

- 以其他列作为搜索条件
  - 从第一页沿着双向链表一直往下找，每页都需要遍历所有记录，然后一一对比是否符合条件，那这样的执行效率非常低。
</div>

<!--
主键为搜索条件其实是相对较快的，但是我们在业务中能全部是主键为搜索条件吗？

在没有索引的条件下，不论是不是以主键搜索，都需要从第一页开始沿着双向链表一直往下找，这样是非常耗时与消耗资源的。

因为所有查询都需要从第一页开始遍历，如果数据量巨大，还需要遍历到最后一页，那执行时间会很久很久。

而且如果一个线程一直在处理慢查询，就会影响到处理其他查询。
-->

---
layout: center
---

# MySQL 中的索引

---

## 一个简单的索引方案

<div style="margin-top: 40px;line-height: 1.8">
  假设我们每页只存几条记录，我们仿照着页生成的页目录，给它们做个目录，每个页对应一个目录项，每个目录项对应着两部分
</div>

<br/>
<br/>

- 页的用户记录中最小的主键值
- 页号

<div style="margin-top: 50px;line-height: 1.8">
  我们只需要把几个目录项在物理存储器中连续存储，比如放在一个数组中，就可以实现根据主键值快速查找某条记录的功能了，那么具体的查找过程就可以分为两步：
</div>

<br/>
<br/>

- 先从目录项中根据二分查找快速定位主键所在的目录项。
- 然后根据目录项找到所对应的页，再根据页目录查找到对应的记录。

---

<img src="https://pic-bed-file.oss-cn-shanghai.aliyuncs.com/1624195232129-image2020-8-19_21-22-26.png" style="width: 90%" />

---

## InnoDB 索引方案

<div style="margin-top: 50px;line-height: 1.8">
  介绍的简单索引方案，是建立在我们假设所有目录项都建立在磁盘的连续空间中，这样随之而来带来一些问题：
</div>

<br/>

- InnoDB 是使用页来作为基本存储单位的，也就是最多能保证 16KB 的连续存储空间，若数据量很多那么就需要非常大的连续存储空间。
- 我们经常需要对记录进行增删，假设我们操作的记录存储在连续存储空间中的第一页，那么后面的所有目录项都需要向前移动一下。

<div style="margin-top: 50px;line-height: 1.8">
  其实目录项和我们存储的记录都是差不多的，只不过存储的内容主要有<strong>主键和页号</strong>而已，所以 MySQL 大佬们，就复用了之前存储用户记录的数据页来存储目录项，为了区分，我们把这样来标识目录项的记录成为“<strong>目录项记录</strong>”，数据库如何区分的呢，利用记录中的头信息里 record_type 值来进行区分。
</div>

---

<img src="https://pic-bed-file.oss-cn-shanghai.aliyuncs.com/1624195246100-image2020-8-19_21-22-45.png" style="margin-top:50px" />

---

<div style="margin-top: 50px;line-height: 1.8">
  虽说目录项记录中只存储主键值和对应的页号，会比用户记录需要的空间小很多，但是一个页只有 16KB 的大小，终归还是有上限的，所以当一个页存满了，会再分配一个页来进行存储，就像存储用户记录一样。
</div>

<div style="margin-top: 20px;">
  现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条记录大致需要三步：
</div>

<style>
.li-margin {
  margin-top: 10px;
}
</style>

<div style="margin-top: 25px;">
  <li>确定目录记录页</li>
  <li class="li-margin">确定记录真实所在页</li>
  <li class="li-margin">确定记录所在具体位置</li>
</div>

<div style="margin-top: 20px;line-height: 1.8">
  那么有个问题，在第一步中我们需要定位存储目录项记录的页，但是这些页在存储空间中也可能不挨着，如果我们数据量很大，产生很多存储目录项记录的页，那么我们怎么根据主键值快速定位一个存储目录项记录的页呢？其实很简单，我们再生成一个更高级的目录即可。
</div>

---

<img src="https://pic-bed-file.oss-cn-shanghai.aliyuncs.com/1624195263530-image2020-8-19_21-23-4.png"  />

---

最终的索引结构就是这样，这就是 B+ 树

<img src="https://pic-bed-file.oss-cn-shanghai.aliyuncs.com/1624199002993-image2020-8-19_21-23-20.png"  />

---
layout: center
---

# 索引的代价

---

<div style="margin-top: 50px;">
  <span style="font-size: 24px;margin-top:20px;">空间上的代价</span>

  <div style="margin-top: 20px;line-height: 1.8">
    &nbsp;&nbsp;每建立一个索引都要为它建立一颗 B+ 树，每一颗 B+ 树的每个节点都是一个数据页，一个页默认占用 16 KB的存储空间，一颗很大的 B+ 树由很多数据页组成，那么就会消耗一大片存储空间。
  </div>
  <br/>
  <br/>
  <br/>
  <span style="font-size: 24px;">时间上的代价</span>
  <div style="margin-top: 20px;line-height: 1.8">
    &nbsp;&nbsp;在增删改操作时，会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录位移，页面分裂、页面回收的操作来维护好节点和记录的排序。
  </div>
</div>

---
layout: center
---

# 索引适用的查询以及注意事项

---

- B+树索引在空间和时间上都有代价，建索引之前需要考虑清楚
- B+树索引适用于的情况
  - 全值匹配
  - 匹配左边的列
  - 匹配范围值
  - 精确匹配某一列并范围匹配另外一列
  - 用于排序
  - 用于分组
- 在使用B+树索引时需要注意下边这些事项
  - 只为用于搜索、排序或分组的列创建索引
  - 为列的基数大的列创建索引
  - 索引列的类型尽量小
  - 可以只对字符串值的前缀建立索引
  - 尽量使用覆盖索引进行查询，避免回表带来的性能损耗。
